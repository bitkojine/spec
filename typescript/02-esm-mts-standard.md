# Standardizing on ESM and .mts

## Background / Motivation
Node.js has traditionally used CommonJS (CJS) as its default module system. However, the industry has shifted towards **ECMAScript Modules (ESM)** as the official standard for JavaScript. ESM provides benefits such as improved static analysis, better tree-shaking, and a consistent module syntax across browser and server environments.

In Node.js, determining whether a file is CJS or ESM can be ambiguous, often relying on the nearest `package.json`'s `"type"` field. This project adopts the **`.mts`** extension for TypeScript files to explicitly signal that they are ES Modules, ensuring absolute clarity for Node.js, TypeScript, and the build toolchain.

## Rule Definition
This codebase enforces the following standards for module management:

- **REQUIRED: .mts Extension**: All new TypeScript source files MUST use the `.mts` extension.
- **REQUIRED: ESM Imports**: All imports MUST use ESM syntax (`import`/`export`). The use of `require()` and `module.exports` is prohibited in source code.
- **REQUIRED: Explicit Extensions**: When importing internal modules, the import path MUST include the explicit **`.mjs`** extension (the compiled target extension).
    - *Rationale*: This is required by the TypeScript `Node16` / `NodeNext` module resolution logic to ensure compatibility with Node.js ESM.
- **REQUIRED: Package Configuration**: The root `package.json` MUST include `"type": "module"`.

## Architectural Layering (Who Decides Resolution)
To maintain a predictable build system, we strictly define which layer owns module resolution:

| Layer | Responsibility | Logic |
| :--- | :--- | :--- |
| **Type Checking** | TypeScript | Governs how source files find each other during static analysis. |
| **Bundling / Build** | Toolchain (esbuild) | MUST comply with TypeScript's resolution rules. No custom heuristics. |
| **Runtime** | Node.js | Loads the emitted `.mjs` files directly. |

> [!IMPORTANT]
> The **TypeScript Compiler** is the source of truth for module resolution. All other tools (bundlers, linters, IDEs) MUST respect the `Node16`/`NodeNext` resolution rules defined in `tsconfig.json` and must not introduce custom extension heuristics that diverge from TypeScript.

## The Dev/Prod Resolution Split
There is a necessary distinction between how modules resolve in development (bundling source) versus production (executing emitted code):

1. **Production (Runtime)**: Node.js sees `import "./foo.mjs"` and loads the literal `.mjs` file generated by the compiler.
2. **Development (Bundling)**: The bundler sees `import "./foo.mjs"` but must find the source file `foo.mts`. 

**The Rule for Bundlers**: During bundling, any mapping from `.mjs` to `.mts` is strictly limited to mirroring the TypeScript 1:1 emit behavior. This mapping exists solely to allow bundling prior to or instead of a separate `tsc` emit step. It MUST NOT include fallback chains or "smart" guessing.

## Preferred Patterns

### Creating New Modules
When creating a new file, name it with the `.mts` extension.
```typescript
// src/utils/math-helper.mts
export const add = (a: number, b: number) => a + b;
```

### Importing Modules
Always refer to the compiled extension (`.mjs`) even though the source is `.mts`.
```typescript
// src/index.mts
import { add } from "./utils/math-helper.mjs";
```

## Examples

### Incorrect Implementation
```typescript
// ❌ Diverging from TypeScript resolution (omitting extension)
import { logger } from "./logger"; 

// ❌ Using CommonJS require
const fs = require("fs"); 
```

### Correct Implementation
```typescript
// ✅ Explicit .mts for source
// ✅ Explicit .mjs for import (matching TS Node16 resolution)
import { logger } from "./logger.mjs"; 

// ✅ Using node: prefix for built-ins
import * as fs from "node:fs"; 
```

## Tooling & Enforcement

### Compiler Configuration
The `tsconfig.json` MUST be configured to enforce `Node16`/`NodeNext` resolution:
```json
{
  "compilerOptions": {
    "module": "Node16",
    "moduleResolution": "Node16"
  }
}
```

### Bundler Compliance
The bundler (e.g., `esbuild.ts`) MUST be configured to respect the `tsconfig.json` resolution. If a plugin is used to bridge `.mjs` imports to `.mts` source files, it must be a deterministic 1:1 mapping with no heuristics.

## Summary
This project is "Pure ESM". We prioritize predictability and maintainability by making **TypeScript** the sole decision-maker for module resolution, ensuring that our development, bundling, and runtime behaviors remain perfectly aligned.
